// Copyright 2025 Redpanda Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.6.0 with parameter "target=ts,import_extension=,js_import_style=legacy_commonjs"
// @generated from file proto/redpanda/core/admin/v2/shadow_link.proto (package redpanda.core.admin.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, FieldMask, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ACLOperation, ACLPattern, ACLPermissionType, ACLResource } from "../../common/acl_pb";

/**
 * State of the shadow link
 *
 * @generated from enum redpanda.core.admin.v2.ShadowLinkState
 */
export enum ShadowLinkState {
  /**
   * Unspecified
   *
   * @generated from enum value: SHADOW_LINK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Shadow link is active
   *
   * @generated from enum value: SHADOW_LINK_STATE_ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Shadow link was paused
   *
   * @generated from enum value: SHADOW_LINK_STATE_PAUSED = 2;
   */
  PAUSED = 2,

  /**
   * Shadow link is in the process of failing over
   *
   * @generated from enum value: SHADOW_LINK_STATE_FAILING_OVER = 3;
   */
  FAILING_OVER = 3,

  /**
   * Shadow link was failed over
   *
   * @generated from enum value: SHADOW_LINK_STATE_FAILED_OVER = 4;
   */
  FAILED_OVER = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ShadowLinkState)
proto3.util.setEnumType(ShadowLinkState, "redpanda.core.admin.v2.ShadowLinkState", [
  { no: 0, name: "SHADOW_LINK_STATE_UNSPECIFIED" },
  { no: 1, name: "SHADOW_LINK_STATE_ACTIVE" },
  { no: 2, name: "SHADOW_LINK_STATE_PAUSED" },
  { no: 3, name: "SHADOW_LINK_STATE_FAILING_OVER" },
  { no: 4, name: "SHADOW_LINK_STATE_FAILED_OVER" },
]);

/**
 * Valid SCRAM mechanisms
 *
 * @generated from enum redpanda.core.admin.v2.ScramMechanism
 */
export enum ScramMechanism {
  /**
   * @generated from enum value: SCRAM_MECHANISM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * SCRAM-SHA-256
   *
   * @generated from enum value: SCRAM_MECHANISM_SCRAM_SHA_256 = 1;
   */
  SCRAM_SHA_256 = 1,

  /**
   * SCRAM-SHA-512
   *
   * @generated from enum value: SCRAM_MECHANISM_SCRAM_SHA_512 = 2;
   */
  SCRAM_SHA_512 = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ScramMechanism)
proto3.util.setEnumType(ScramMechanism, "redpanda.core.admin.v2.ScramMechanism", [
  { no: 0, name: "SCRAM_MECHANISM_UNSPECIFIED" },
  { no: 1, name: "SCRAM_MECHANISM_SCRAM_SHA_256" },
  { no: 2, name: "SCRAM_MECHANISM_SCRAM_SHA_512" },
]);

/**
 * The matching pattern type
 *
 * @generated from enum redpanda.core.admin.v2.PatternType
 */
export enum PatternType {
  /**
   * @generated from enum value: PATTERN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Must match the filter exactly
   *
   * @generated from enum value: PATTERN_TYPE_LITERAL = 1;
   */
  LITERAL = 1,

  /**
   * Will match anything that starts with filter
   *
   * @generated from enum value: PATTERN_TYPE_PREFIX = 2;
   */
  PREFIX = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PatternType)
proto3.util.setEnumType(PatternType, "redpanda.core.admin.v2.PatternType", [
  { no: 0, name: "PATTERN_TYPE_UNSPECIFIED" },
  { no: 1, name: "PATTERN_TYPE_LITERAL" },
  { no: 2, name: "PATTERN_TYPE_PREFIX" },
]);

/**
 * What type of filter this is, include or exclude
 *
 * @generated from enum redpanda.core.admin.v2.FilterType
 */
export enum FilterType {
  /**
   * @generated from enum value: FILTER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Include the items that match the filter
   *
   * @generated from enum value: FILTER_TYPE_INCLUDE = 1;
   */
  INCLUDE = 1,

  /**
   * Exclude the items that match the filter
   *
   * @generated from enum value: FILTER_TYPE_EXCLUDE = 2;
   */
  EXCLUDE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FilterType)
proto3.util.setEnumType(FilterType, "redpanda.core.admin.v2.FilterType", [
  { no: 0, name: "FILTER_TYPE_UNSPECIFIED" },
  { no: 1, name: "FILTER_TYPE_INCLUDE" },
  { no: 2, name: "FILTER_TYPE_EXCLUDE" },
]);

/**
 * Task states
 *
 * @generated from enum redpanda.core.admin.v2.TaskState
 */
export enum TaskState {
  /**
   * @generated from enum value: TASK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Task is active
   *
   * @generated from enum value: TASK_STATE_ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Task was paused
   *
   * @generated from enum value: TASK_STATE_PAUSED = 2;
   */
  PAUSED = 2,

  /**
   * Task is unable to communicate with source cluster
   *
   * @generated from enum value: TASK_STATE_LINK_UNAVAILABLE = 3;
   */
  LINK_UNAVAILABLE = 3,

  /**
   * Task is not running
   *
   * @generated from enum value: TASK_STATE_NOT_RUNNING = 4;
   */
  NOT_RUNNING = 4,

  /**
   * Task is faulted
   *
   * @generated from enum value: TASK_STATE_FAULTED = 5;
   */
  FAULTED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskState)
proto3.util.setEnumType(TaskState, "redpanda.core.admin.v2.TaskState", [
  { no: 0, name: "TASK_STATE_UNSPECIFIED" },
  { no: 1, name: "TASK_STATE_ACTIVE" },
  { no: 2, name: "TASK_STATE_PAUSED" },
  { no: 3, name: "TASK_STATE_LINK_UNAVAILABLE" },
  { no: 4, name: "TASK_STATE_NOT_RUNNING" },
  { no: 5, name: "TASK_STATE_FAULTED" },
]);

/**
 * State of a shadow topic
 *
 * @generated from enum redpanda.core.admin.v2.ShadowTopicState
 */
export enum ShadowTopicState {
  /**
   * @generated from enum value: SHADOW_TOPIC_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Shadow topic is active
   *
   * @generated from enum value: SHADOW_TOPIC_STATE_ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Shadow topic has been promoted
   *
   * @generated from enum value: SHADOW_TOPIC_STATE_PROMOTED = 2;
   */
  PROMOTED = 2,

  /**
   * Shadow topic has faulted
   *
   * @generated from enum value: SHADOW_TOPIC_STATE_FAULTED = 3;
   */
  FAULTED = 3,

  /**
   * Shadow topic has been paused
   *
   * @generated from enum value: SHADOW_TOPIC_STATE_PAUSED = 4;
   */
  PAUSED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ShadowTopicState)
proto3.util.setEnumType(ShadowTopicState, "redpanda.core.admin.v2.ShadowTopicState", [
  { no: 0, name: "SHADOW_TOPIC_STATE_UNSPECIFIED" },
  { no: 1, name: "SHADOW_TOPIC_STATE_ACTIVE" },
  { no: 2, name: "SHADOW_TOPIC_STATE_PROMOTED" },
  { no: 3, name: "SHADOW_TOPIC_STATE_FAULTED" },
  { no: 4, name: "SHADOW_TOPIC_STATE_PAUSED" },
]);

/**
 * A ShadowLink resource
 *
 * @generated from message redpanda.core.admin.v2.ShadowLink
 */
export class ShadowLink extends Message<ShadowLink> {
  /**
   * The name of the shadow link
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The UUID of the shadow link
   *
   * @generated from field: string uid = 2;
   */
  uid = "";

  /**
   * Shadow link configuration
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLinkConfigurations configurations = 3;
   */
  configurations?: ShadowLinkConfigurations;

  /**
   * Status of the shadow link
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLinkStatus status = 4;
   */
  status?: ShadowLinkStatus;

  constructor(data?: PartialMessage<ShadowLink>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ShadowLink";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "configurations", kind: "message", T: ShadowLinkConfigurations },
    { no: 4, name: "status", kind: "message", T: ShadowLinkStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShadowLink {
    return new ShadowLink().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShadowLink {
    return new ShadowLink().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShadowLink {
    return new ShadowLink().fromJsonString(jsonString, options);
  }

  static equals(a: ShadowLink | PlainMessage<ShadowLink> | undefined, b: ShadowLink | PlainMessage<ShadowLink> | undefined): boolean {
    return proto3.util.equals(ShadowLink, a, b);
  }
}

/**
 * Create a new shadow link
 *
 * @generated from message redpanda.core.admin.v2.CreateShadowLinkRequest
 */
export class CreateShadowLinkRequest extends Message<CreateShadowLinkRequest> {
  /**
   * The shadow link to create
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLink shadow_link = 1;
   */
  shadowLink?: ShadowLink;

  constructor(data?: PartialMessage<CreateShadowLinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.CreateShadowLinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_link", kind: "message", T: ShadowLink },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateShadowLinkRequest {
    return new CreateShadowLinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateShadowLinkRequest {
    return new CreateShadowLinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateShadowLinkRequest {
    return new CreateShadowLinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateShadowLinkRequest | PlainMessage<CreateShadowLinkRequest> | undefined, b: CreateShadowLinkRequest | PlainMessage<CreateShadowLinkRequest> | undefined): boolean {
    return proto3.util.equals(CreateShadowLinkRequest, a, b);
  }
}

/**
 * Response to creating a shadow link
 *
 * @generated from message redpanda.core.admin.v2.CreateShadowLinkResponse
 */
export class CreateShadowLinkResponse extends Message<CreateShadowLinkResponse> {
  /**
   * The shadow link that was created
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLink shadow_link = 1;
   */
  shadowLink?: ShadowLink;

  constructor(data?: PartialMessage<CreateShadowLinkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.CreateShadowLinkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_link", kind: "message", T: ShadowLink },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateShadowLinkResponse {
    return new CreateShadowLinkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateShadowLinkResponse {
    return new CreateShadowLinkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateShadowLinkResponse {
    return new CreateShadowLinkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateShadowLinkResponse | PlainMessage<CreateShadowLinkResponse> | undefined, b: CreateShadowLinkResponse | PlainMessage<CreateShadowLinkResponse> | undefined): boolean {
    return proto3.util.equals(CreateShadowLinkResponse, a, b);
  }
}

/**
 * Request to delete a shadow link
 *
 * @generated from message redpanda.core.admin.v2.DeleteShadowLinkRequest
 */
export class DeleteShadowLinkRequest extends Message<DeleteShadowLinkRequest> {
  /**
   * The name of the link to delete
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteShadowLinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.DeleteShadowLinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteShadowLinkRequest {
    return new DeleteShadowLinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteShadowLinkRequest {
    return new DeleteShadowLinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteShadowLinkRequest {
    return new DeleteShadowLinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteShadowLinkRequest | PlainMessage<DeleteShadowLinkRequest> | undefined, b: DeleteShadowLinkRequest | PlainMessage<DeleteShadowLinkRequest> | undefined): boolean {
    return proto3.util.equals(DeleteShadowLinkRequest, a, b);
  }
}

/**
 * Response to deleting a shadow link
 *
 * @generated from message redpanda.core.admin.v2.DeleteShadowLinkResponse
 */
export class DeleteShadowLinkResponse extends Message<DeleteShadowLinkResponse> {
  constructor(data?: PartialMessage<DeleteShadowLinkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.DeleteShadowLinkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteShadowLinkResponse {
    return new DeleteShadowLinkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteShadowLinkResponse {
    return new DeleteShadowLinkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteShadowLinkResponse {
    return new DeleteShadowLinkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteShadowLinkResponse | PlainMessage<DeleteShadowLinkResponse> | undefined, b: DeleteShadowLinkResponse | PlainMessage<DeleteShadowLinkResponse> | undefined): boolean {
    return proto3.util.equals(DeleteShadowLinkResponse, a, b);
  }
}

/**
 * Request to get the information about a shadow link
 *
 * @generated from message redpanda.core.admin.v2.GetShadowLinkRequest
 */
export class GetShadowLinkRequest extends Message<GetShadowLinkRequest> {
  /**
   * The name of the shadow link to get
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetShadowLinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.GetShadowLinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetShadowLinkRequest {
    return new GetShadowLinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetShadowLinkRequest {
    return new GetShadowLinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetShadowLinkRequest {
    return new GetShadowLinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetShadowLinkRequest | PlainMessage<GetShadowLinkRequest> | undefined, b: GetShadowLinkRequest | PlainMessage<GetShadowLinkRequest> | undefined): boolean {
    return proto3.util.equals(GetShadowLinkRequest, a, b);
  }
}

/**
 * Response to getting a shadow link
 *
 * @generated from message redpanda.core.admin.v2.GetShadowLinkResponse
 */
export class GetShadowLinkResponse extends Message<GetShadowLinkResponse> {
  /**
   * The shadow link that was retrieved
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLink shadow_link = 1;
   */
  shadowLink?: ShadowLink;

  constructor(data?: PartialMessage<GetShadowLinkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.GetShadowLinkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_link", kind: "message", T: ShadowLink },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetShadowLinkResponse {
    return new GetShadowLinkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetShadowLinkResponse {
    return new GetShadowLinkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetShadowLinkResponse {
    return new GetShadowLinkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetShadowLinkResponse | PlainMessage<GetShadowLinkResponse> | undefined, b: GetShadowLinkResponse | PlainMessage<GetShadowLinkResponse> | undefined): boolean {
    return proto3.util.equals(GetShadowLinkResponse, a, b);
  }
}

/**
 * Request to list all shadow links
 *
 * @generated from message redpanda.core.admin.v2.ListShadowLinksRequest
 */
export class ListShadowLinksRequest extends Message<ListShadowLinksRequest> {
  constructor(data?: PartialMessage<ListShadowLinksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ListShadowLinksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListShadowLinksRequest {
    return new ListShadowLinksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListShadowLinksRequest {
    return new ListShadowLinksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListShadowLinksRequest {
    return new ListShadowLinksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListShadowLinksRequest | PlainMessage<ListShadowLinksRequest> | undefined, b: ListShadowLinksRequest | PlainMessage<ListShadowLinksRequest> | undefined): boolean {
    return proto3.util.equals(ListShadowLinksRequest, a, b);
  }
}

/**
 * All shadow links on the cluster
 *
 * @generated from message redpanda.core.admin.v2.ListShadowLinksResponse
 */
export class ListShadowLinksResponse extends Message<ListShadowLinksResponse> {
  /**
   * The shadow links
   *
   * @generated from field: repeated redpanda.core.admin.v2.ShadowLink shadow_links = 1;
   */
  shadowLinks: ShadowLink[] = [];

  constructor(data?: PartialMessage<ListShadowLinksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ListShadowLinksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_links", kind: "message", T: ShadowLink, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListShadowLinksResponse {
    return new ListShadowLinksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListShadowLinksResponse {
    return new ListShadowLinksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListShadowLinksResponse {
    return new ListShadowLinksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListShadowLinksResponse | PlainMessage<ListShadowLinksResponse> | undefined, b: ListShadowLinksResponse | PlainMessage<ListShadowLinksResponse> | undefined): boolean {
    return proto3.util.equals(ListShadowLinksResponse, a, b);
  }
}

/**
 * Updates a shadow link
 *
 * @generated from message redpanda.core.admin.v2.UpdateShadowLinkRequest
 */
export class UpdateShadowLinkRequest extends Message<UpdateShadowLinkRequest> {
  /**
   * The shadow link to update
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLink shadow_link = 1;
   */
  shadowLink?: ShadowLink;

  /**
   * The list of fields to update
   * See [AIP-134](https://google.aip.dev/134) for how to use `field_mask`
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateShadowLinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.UpdateShadowLinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_link", kind: "message", T: ShadowLink },
    { no: 2, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateShadowLinkRequest {
    return new UpdateShadowLinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateShadowLinkRequest {
    return new UpdateShadowLinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateShadowLinkRequest {
    return new UpdateShadowLinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateShadowLinkRequest | PlainMessage<UpdateShadowLinkRequest> | undefined, b: UpdateShadowLinkRequest | PlainMessage<UpdateShadowLinkRequest> | undefined): boolean {
    return proto3.util.equals(UpdateShadowLinkRequest, a, b);
  }
}

/**
 * Response to the update shadow link request
 *
 * @generated from message redpanda.core.admin.v2.UpdateShadowLinkResponse
 */
export class UpdateShadowLinkResponse extends Message<UpdateShadowLinkResponse> {
  /**
   * The shadow link that was updated
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLink shadow_link = 1;
   */
  shadowLink?: ShadowLink;

  constructor(data?: PartialMessage<UpdateShadowLinkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.UpdateShadowLinkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_link", kind: "message", T: ShadowLink },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateShadowLinkResponse {
    return new UpdateShadowLinkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateShadowLinkResponse {
    return new UpdateShadowLinkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateShadowLinkResponse {
    return new UpdateShadowLinkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateShadowLinkResponse | PlainMessage<UpdateShadowLinkResponse> | undefined, b: UpdateShadowLinkResponse | PlainMessage<UpdateShadowLinkResponse> | undefined): boolean {
    return proto3.util.equals(UpdateShadowLinkResponse, a, b);
  }
}

/**
 * Request to fail over a shadow link or a single shadow topic
 *
 * @generated from message redpanda.core.admin.v2.FailOverRequest
 */
export class FailOverRequest extends Message<FailOverRequest> {
  /**
   * The name of the shadow link to fail over
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The name of the shadow topic to fail over, if not set will fail over
   * the entire shadow link
   *
   * @generated from field: string shadow_topic_name = 2;
   */
  shadowTopicName = "";

  constructor(data?: PartialMessage<FailOverRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.FailOverRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shadow_topic_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FailOverRequest {
    return new FailOverRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FailOverRequest {
    return new FailOverRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FailOverRequest {
    return new FailOverRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FailOverRequest | PlainMessage<FailOverRequest> | undefined, b: FailOverRequest | PlainMessage<FailOverRequest> | undefined): boolean {
    return proto3.util.equals(FailOverRequest, a, b);
  }
}

/**
 * The response to the FailOverRequest
 *
 * @generated from message redpanda.core.admin.v2.FailOverResponse
 */
export class FailOverResponse extends Message<FailOverResponse> {
  /**
   * The shadow link that was failed over
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLink shadow_link = 1;
   */
  shadowLink?: ShadowLink;

  constructor(data?: PartialMessage<FailOverResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.FailOverResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadow_link", kind: "message", T: ShadowLink },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FailOverResponse {
    return new FailOverResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FailOverResponse {
    return new FailOverResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FailOverResponse {
    return new FailOverResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FailOverResponse | PlainMessage<FailOverResponse> | undefined, b: FailOverResponse | PlainMessage<FailOverResponse> | undefined): boolean {
    return proto3.util.equals(FailOverResponse, a, b);
  }
}

/**
 * ShadowLink options
 *
 * @generated from message redpanda.core.admin.v2.ShadowLinkConfigurations
 */
export class ShadowLinkConfigurations extends Message<ShadowLinkConfigurations> {
  /**
   * Configuration for the internal kafka client
   *
   * @generated from field: redpanda.core.admin.v2.ShadowLinkClientOptions client_options = 1;
   */
  clientOptions?: ShadowLinkClientOptions;

  /**
   * Topic metadata sync options
   *
   * @generated from field: redpanda.core.admin.v2.TopicMetadataSyncOptions topic_metadata_sync_options = 2;
   */
  topicMetadataSyncOptions?: TopicMetadataSyncOptions;

  /**
   * Consumer offset sync options
   *
   * @generated from field: redpanda.core.admin.v2.ConsumerOffsetSyncOptions consumer_offset_sync_options = 3;
   */
  consumerOffsetSyncOptions?: ConsumerOffsetSyncOptions;

  /**
   * Security settings sync options
   *
   * @generated from field: redpanda.core.admin.v2.SecuritySettingsSyncOptions security_sync_options = 4;
   */
  securitySyncOptions?: SecuritySettingsSyncOptions;

  constructor(data?: PartialMessage<ShadowLinkConfigurations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ShadowLinkConfigurations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_options", kind: "message", T: ShadowLinkClientOptions },
    { no: 2, name: "topic_metadata_sync_options", kind: "message", T: TopicMetadataSyncOptions },
    { no: 3, name: "consumer_offset_sync_options", kind: "message", T: ConsumerOffsetSyncOptions },
    { no: 4, name: "security_sync_options", kind: "message", T: SecuritySettingsSyncOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShadowLinkConfigurations {
    return new ShadowLinkConfigurations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShadowLinkConfigurations {
    return new ShadowLinkConfigurations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShadowLinkConfigurations {
    return new ShadowLinkConfigurations().fromJsonString(jsonString, options);
  }

  static equals(a: ShadowLinkConfigurations | PlainMessage<ShadowLinkConfigurations> | undefined, b: ShadowLinkConfigurations | PlainMessage<ShadowLinkConfigurations> | undefined): boolean {
    return proto3.util.equals(ShadowLinkConfigurations, a, b);
  }
}

/**
 * Options for the client link
 *
 * @generated from message redpanda.core.admin.v2.ShadowLinkClientOptions
 */
export class ShadowLinkClientOptions extends Message<ShadowLinkClientOptions> {
  /**
   * The bootstrap servers to use
   *
   * @generated from field: repeated string bootstrap_servers = 1;
   */
  bootstrapServers: string[] = [];

  /**
   * The Client ID for the Kafka RPC requests setn by this cluster to the
   * source cluster
   *
   * @generated from field: string client_id = 2;
   */
  clientId = "";

  /**
   * If provided, this is the expected ID of the source cluster.  If it does
   * not match then the connection will be rejected.  If provided, this value
   * must match the `ClusterId` field returned in the Kafka Metadata response
   * message
   *
   * @generated from field: string source_cluster_id = 3;
   */
  sourceClusterId = "";

  /**
   * TLS settings
   *
   * @generated from field: optional redpanda.core.admin.v2.TLSSettings tls_settings = 4;
   */
  tlsSettings?: TLSSettings;

  /**
   * Authentication settings
   *
   * @generated from field: optional redpanda.core.admin.v2.AuthenticationConfiguration authentication_configuration = 5;
   */
  authenticationConfiguration?: AuthenticationConfiguration;

  /**
   * Max metadata age
   * If 0 is provided, defaults to 10 seconds
   *
   * @generated from field: int32 metadata_max_age_ms = 6;
   */
  metadataMaxAgeMs = 0;

  /**
   * Connection timeout
   * If 0 is provided, defaults to 1 second
   *
   * @generated from field: int32 connection_timeout_ms = 7;
   */
  connectionTimeoutMs = 0;

  /**
   * Retry base backoff
   * If 0 is provided, defaults to 100ms
   *
   * @generated from field: int32 retry_backoff_ms = 8;
   */
  retryBackoffMs = 0;

  /**
   * Fetch request timeout
   * If 0 is provided, defaults to 100ms
   *
   * @generated from field: int32 fetch_wait_max_ms = 9;
   */
  fetchWaitMaxMs = 0;

  /**
   * Fetch min bytes
   * If 0 is provided, defaults to 1 byte
   *
   * @generated from field: int32 fetch_min_bytes = 10;
   */
  fetchMinBytes = 0;

  /**
   * Fetch max bytes
   * If 0 is provided, defaults to 1MiB
   *
   * @generated from field: int32 fetch_max_bytes = 11;
   */
  fetchMaxBytes = 0;

  constructor(data?: PartialMessage<ShadowLinkClientOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ShadowLinkClientOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bootstrap_servers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "source_cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "tls_settings", kind: "message", T: TLSSettings, opt: true },
    { no: 5, name: "authentication_configuration", kind: "message", T: AuthenticationConfiguration, opt: true },
    { no: 6, name: "metadata_max_age_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "connection_timeout_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "retry_backoff_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "fetch_wait_max_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 10, name: "fetch_min_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "fetch_max_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShadowLinkClientOptions {
    return new ShadowLinkClientOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShadowLinkClientOptions {
    return new ShadowLinkClientOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShadowLinkClientOptions {
    return new ShadowLinkClientOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ShadowLinkClientOptions | PlainMessage<ShadowLinkClientOptions> | undefined, b: ShadowLinkClientOptions | PlainMessage<ShadowLinkClientOptions> | undefined): boolean {
    return proto3.util.equals(ShadowLinkClientOptions, a, b);
  }
}

/**
 * Options for syncing topic metadata
 *
 * @generated from message redpanda.core.admin.v2.TopicMetadataSyncOptions
 */
export class TopicMetadataSyncOptions extends Message<TopicMetadataSyncOptions> {
  /**
   * How often to sync metadata
   * If 0 provided, defaults to 30 seconds
   *
   * @generated from field: google.protobuf.Duration interval = 1;
   */
  interval?: Duration;

  /**
   * The topic filters to use
   *
   * @generated from field: repeated redpanda.core.admin.v2.NameFilter topic_filters = 2;
   */
  topicFilters: NameFilter[] = [];

  /**
   * Additional topic properties to shadow
   * Partition count, `max.message.bytes`, `cleanup.policy` and
   * `timestamp.type` will always be replicated
   *
   * @generated from field: repeated string shadowed_topic_properties = 3;
   */
  shadowedTopicProperties: string[] = [];

  constructor(data?: PartialMessage<TopicMetadataSyncOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.TopicMetadataSyncOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interval", kind: "message", T: Duration },
    { no: 2, name: "topic_filters", kind: "message", T: NameFilter, repeated: true },
    { no: 3, name: "shadowed_topic_properties", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopicMetadataSyncOptions {
    return new TopicMetadataSyncOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopicMetadataSyncOptions {
    return new TopicMetadataSyncOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopicMetadataSyncOptions {
    return new TopicMetadataSyncOptions().fromJsonString(jsonString, options);
  }

  static equals(a: TopicMetadataSyncOptions | PlainMessage<TopicMetadataSyncOptions> | undefined, b: TopicMetadataSyncOptions | PlainMessage<TopicMetadataSyncOptions> | undefined): boolean {
    return proto3.util.equals(TopicMetadataSyncOptions, a, b);
  }
}

/**
 * Options for syncing consumer offsets
 *
 * @generated from message redpanda.core.admin.v2.ConsumerOffsetSyncOptions
 */
export class ConsumerOffsetSyncOptions extends Message<ConsumerOffsetSyncOptions> {
  /**
   * Sync interval
   * If 0 provided, defaults to 30 seconds
   *
   * @generated from field: google.protobuf.Duration interval = 1;
   */
  interval?: Duration;

  /**
   * Whether it's enabled
   *
   * @generated from field: bool enabled = 2;
   */
  enabled = false;

  /**
   * The filters
   *
   * @generated from field: repeated redpanda.core.admin.v2.NameFilter group_filters = 3;
   */
  groupFilters: NameFilter[] = [];

  constructor(data?: PartialMessage<ConsumerOffsetSyncOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ConsumerOffsetSyncOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interval", kind: "message", T: Duration },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "group_filters", kind: "message", T: NameFilter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsumerOffsetSyncOptions {
    return new ConsumerOffsetSyncOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsumerOffsetSyncOptions {
    return new ConsumerOffsetSyncOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsumerOffsetSyncOptions {
    return new ConsumerOffsetSyncOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ConsumerOffsetSyncOptions | PlainMessage<ConsumerOffsetSyncOptions> | undefined, b: ConsumerOffsetSyncOptions | PlainMessage<ConsumerOffsetSyncOptions> | undefined): boolean {
    return proto3.util.equals(ConsumerOffsetSyncOptions, a, b);
  }
}

/**
 * Options for syncing security settings
 *
 * @generated from message redpanda.core.admin.v2.SecuritySettingsSyncOptions
 */
export class SecuritySettingsSyncOptions extends Message<SecuritySettingsSyncOptions> {
  /**
   * Sync interval
   * If 0 provided, defaults to 30 seconds
   *
   * @generated from field: google.protobuf.Duration interval = 1;
   */
  interval?: Duration;

  /**
   * Whether or not it's enabled
   *
   * @generated from field: bool enabled = 2;
   */
  enabled = false;

  /**
   * Role filters
   *
   * @generated from field: repeated redpanda.core.admin.v2.NameFilter role_filters = 3;
   */
  roleFilters: NameFilter[] = [];

  /**
   * SCRAM credential filters
   *
   * @generated from field: repeated redpanda.core.admin.v2.NameFilter scram_cred_filters = 4;
   */
  scramCredFilters: NameFilter[] = [];

  /**
   * ACL filters
   *
   * @generated from field: repeated redpanda.core.admin.v2.ACLFilter acl_filters = 5;
   */
  aclFilters: ACLFilter[] = [];

  constructor(data?: PartialMessage<SecuritySettingsSyncOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.SecuritySettingsSyncOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interval", kind: "message", T: Duration },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "role_filters", kind: "message", T: NameFilter, repeated: true },
    { no: 4, name: "scram_cred_filters", kind: "message", T: NameFilter, repeated: true },
    { no: 5, name: "acl_filters", kind: "message", T: ACLFilter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecuritySettingsSyncOptions {
    return new SecuritySettingsSyncOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecuritySettingsSyncOptions {
    return new SecuritySettingsSyncOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecuritySettingsSyncOptions {
    return new SecuritySettingsSyncOptions().fromJsonString(jsonString, options);
  }

  static equals(a: SecuritySettingsSyncOptions | PlainMessage<SecuritySettingsSyncOptions> | undefined, b: SecuritySettingsSyncOptions | PlainMessage<SecuritySettingsSyncOptions> | undefined): boolean {
    return proto3.util.equals(SecuritySettingsSyncOptions, a, b);
  }
}

/**
 * TLS settings
 *
 * @generated from message redpanda.core.admin.v2.TLSSettings
 */
export class TLSSettings extends Message<TLSSettings> {
  /**
   * May provide TLS as a set of files or PEM values
   *
   * @generated from oneof redpanda.core.admin.v2.TLSSettings.tls_settings
   */
  tlsSettings: {
    /**
     * Certificates and keys are provided as files
     *
     * @generated from field: redpanda.core.admin.v2.TLSFileSettings tls_file_settings = 1;
     */
    value: TLSFileSettings;
    case: "tlsFileSettings";
  } | {
    /**
     * Certificates and keys are provided in PEM format
     *
     * @generated from field: redpanda.core.admin.v2.TLSPEMSettings tls_pem_settings = 2;
     */
    value: TLSPEMSettings;
    case: "tlsPemSettings";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TLSSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.TLSSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tls_file_settings", kind: "message", T: TLSFileSettings, oneof: "tls_settings" },
    { no: 2, name: "tls_pem_settings", kind: "message", T: TLSPEMSettings, oneof: "tls_settings" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSSettings {
    return new TLSSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSSettings {
    return new TLSSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSSettings {
    return new TLSSettings().fromJsonString(jsonString, options);
  }

  static equals(a: TLSSettings | PlainMessage<TLSSettings> | undefined, b: TLSSettings | PlainMessage<TLSSettings> | undefined): boolean {
    return proto3.util.equals(TLSSettings, a, b);
  }
}

/**
 * Authentication config.  Currently only supporting SASL/SCRAM,
 * however made as a oneof for expansion
 *
 * @generated from message redpanda.core.admin.v2.AuthenticationConfiguration
 */
export class AuthenticationConfiguration extends Message<AuthenticationConfiguration> {
  /**
   * @generated from oneof redpanda.core.admin.v2.AuthenticationConfiguration.authentication
   */
  authentication: {
    /**
     * SASL/SCRAM configuration
     *
     * @generated from field: redpanda.core.admin.v2.ScramConfig scram_configuration = 1;
     */
    value: ScramConfig;
    case: "scramConfiguration";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuthenticationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.AuthenticationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scram_configuration", kind: "message", T: ScramConfig, oneof: "authentication" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticationConfiguration {
    return new AuthenticationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticationConfiguration {
    return new AuthenticationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticationConfiguration {
    return new AuthenticationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticationConfiguration | PlainMessage<AuthenticationConfiguration> | undefined, b: AuthenticationConfiguration | PlainMessage<AuthenticationConfiguration> | undefined): boolean {
    return proto3.util.equals(AuthenticationConfiguration, a, b);
  }
}

/**
 * TLS file settings
 *
 * @generated from message redpanda.core.admin.v2.TLSFileSettings
 */
export class TLSFileSettings extends Message<TLSFileSettings> {
  /**
   * Path to the CA
   *
   * @generated from field: string ca_path = 1;
   */
  caPath = "";

  /**
   * Key and Cert are optional but if one is provided, then both must be
   * Path to the key
   *
   * @generated from field: string key_path = 2;
   */
  keyPath = "";

  /**
   * Path to the cert
   *
   * @generated from field: string cert_path = 3;
   */
  certPath = "";

  constructor(data?: PartialMessage<TLSFileSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.TLSFileSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ca_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cert_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSFileSettings {
    return new TLSFileSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSFileSettings {
    return new TLSFileSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSFileSettings {
    return new TLSFileSettings().fromJsonString(jsonString, options);
  }

  static equals(a: TLSFileSettings | PlainMessage<TLSFileSettings> | undefined, b: TLSFileSettings | PlainMessage<TLSFileSettings> | undefined): boolean {
    return proto3.util.equals(TLSFileSettings, a, b);
  }
}

/**
 * Used when providing the TLS information in PEM format
 *
 * @generated from message redpanda.core.admin.v2.TLSPEMSettings
 */
export class TLSPEMSettings extends Message<TLSPEMSettings> {
  /**
   * The CA
   *
   * @generated from field: string ca = 1;
   */
  ca = "";

  /**
   * Key and Cert are optional but if one is provided, then both must be
   * The key
   *
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * The SHA-256 of the key, in base64 format
   *
   * @generated from field: string key_fingerprint = 3;
   */
  keyFingerprint = "";

  /**
   * The cert
   *
   * @generated from field: string cert = 4;
   */
  cert = "";

  constructor(data?: PartialMessage<TLSPEMSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.TLSPEMSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ca", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "key_fingerprint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "cert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSPEMSettings {
    return new TLSPEMSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSPEMSettings {
    return new TLSPEMSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSPEMSettings {
    return new TLSPEMSettings().fromJsonString(jsonString, options);
  }

  static equals(a: TLSPEMSettings | PlainMessage<TLSPEMSettings> | undefined, b: TLSPEMSettings | PlainMessage<TLSPEMSettings> | undefined): boolean {
    return proto3.util.equals(TLSPEMSettings, a, b);
  }
}

/**
 * SCRAM settings
 *
 * @generated from message redpanda.core.admin.v2.ScramConfig
 */
export class ScramConfig extends Message<ScramConfig> {
  /**
   * SCRAM username
   *
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * Password
   *
   * @generated from field: string password = 2;
   */
  password = "";

  /**
   * Indicates that the password has been set
   *
   * @generated from field: bool password_set = 3;
   */
  passwordSet = false;

  /**
   * Timestamp of when the password was last set - only valid if password_set
   * is true
   *
   * @generated from field: google.protobuf.Timestamp password_set_at = 4;
   */
  passwordSetAt?: Timestamp;

  /**
   * The SCRAM mechanism to use
   *
   * @generated from field: redpanda.core.admin.v2.ScramMechanism scram_mechanism = 5;
   */
  scramMechanism = ScramMechanism.UNSPECIFIED;

  constructor(data?: PartialMessage<ScramConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ScramConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "password_set", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "password_set_at", kind: "message", T: Timestamp },
    { no: 5, name: "scram_mechanism", kind: "enum", T: proto3.getEnumType(ScramMechanism) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScramConfig {
    return new ScramConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScramConfig {
    return new ScramConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScramConfig {
    return new ScramConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ScramConfig | PlainMessage<ScramConfig> | undefined, b: ScramConfig | PlainMessage<ScramConfig> | undefined): boolean {
    return proto3.util.equals(ScramConfig, a, b);
  }
}

/**
 * A filter based on the name of a resource
 *
 * @generated from message redpanda.core.admin.v2.NameFilter
 */
export class NameFilter extends Message<NameFilter> {
  /**
   * Literal or prefix
   *
   * @generated from field: redpanda.core.admin.v2.PatternType pattern_type = 1;
   */
  patternType = PatternType.UNSPECIFIED;

  /**
   * Include or exclude
   *
   * @generated from field: redpanda.core.admin.v2.FilterType filter_type = 2;
   */
  filterType = FilterType.UNSPECIFIED;

  /**
   * The resource name, or "*"
   * Note if "*", must be the _only_ character
   * and `pattern_type` must be `PATTERN_TYPE_LITERAL`
   *
   * @generated from field: string name = 3;
   */
  name = "";

  constructor(data?: PartialMessage<NameFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.NameFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pattern_type", kind: "enum", T: proto3.getEnumType(PatternType) },
    { no: 2, name: "filter_type", kind: "enum", T: proto3.getEnumType(FilterType) },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NameFilter {
    return new NameFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NameFilter {
    return new NameFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NameFilter {
    return new NameFilter().fromJsonString(jsonString, options);
  }

  static equals(a: NameFilter | PlainMessage<NameFilter> | undefined, b: NameFilter | PlainMessage<NameFilter> | undefined): boolean {
    return proto3.util.equals(NameFilter, a, b);
  }
}

/**
 * A filter for ACLs
 *
 * @generated from message redpanda.core.admin.v2.ACLFilter
 */
export class ACLFilter extends Message<ACLFilter> {
  /**
   * The resource filter
   *
   * @generated from field: redpanda.core.admin.v2.ACLResourceFilter resource_filter = 1;
   */
  resourceFilter?: ACLResourceFilter;

  /**
   * The access filter
   *
   * @generated from field: redpanda.core.admin.v2.ACLAccessFilter access_filter = 2;
   */
  accessFilter?: ACLAccessFilter;

  constructor(data?: PartialMessage<ACLFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ACLFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_filter", kind: "message", T: ACLResourceFilter },
    { no: 2, name: "access_filter", kind: "message", T: ACLAccessFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACLFilter {
    return new ACLFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACLFilter {
    return new ACLFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACLFilter {
    return new ACLFilter().fromJsonString(jsonString, options);
  }

  static equals(a: ACLFilter | PlainMessage<ACLFilter> | undefined, b: ACLFilter | PlainMessage<ACLFilter> | undefined): boolean {
    return proto3.util.equals(ACLFilter, a, b);
  }
}

/**
 * A filter to match ACLs for resources
 *
 * @generated from message redpanda.core.admin.v2.ACLResourceFilter
 */
export class ACLResourceFilter extends Message<ACLResourceFilter> {
  /**
   * The ACL resource type to match
   *
   * @generated from field: redpanda.core.common.ACLResource resource_type = 1;
   */
  resourceType = ACLResource.ACL_RESOURCE_UNSPECIFIED;

  /**
   * The pattern to apply to name
   *
   * @generated from field: redpanda.core.common.ACLPattern pattern_type = 2;
   */
  patternType = ACLPattern.ACL_PATTERN_UNSPECIFIED;

  /**
   * Name, if not given will default to match all items in `resource_type`.
   * Note that asterisk `*` is literal and matches resource ACLs
   * that are named `*`
   *
   * @generated from field: string name = 3;
   */
  name = "";

  constructor(data?: PartialMessage<ACLResourceFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ACLResourceFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_type", kind: "enum", T: proto3.getEnumType(ACLResource) },
    { no: 2, name: "pattern_type", kind: "enum", T: proto3.getEnumType(ACLPattern) },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACLResourceFilter {
    return new ACLResourceFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACLResourceFilter {
    return new ACLResourceFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACLResourceFilter {
    return new ACLResourceFilter().fromJsonString(jsonString, options);
  }

  static equals(a: ACLResourceFilter | PlainMessage<ACLResourceFilter> | undefined, b: ACLResourceFilter | PlainMessage<ACLResourceFilter> | undefined): boolean {
    return proto3.util.equals(ACLResourceFilter, a, b);
  }
}

/**
 * Filter an ACL based on its access
 *
 * @generated from message redpanda.core.admin.v2.ACLAccessFilter
 */
export class ACLAccessFilter extends Message<ACLAccessFilter> {
  /**
   * The name of the principal, if not set will default to match
   * all principals with the specified `operation` and `permission_type`
   *
   * @generated from field: string principal = 1;
   */
  principal = "";

  /**
   * The ACL operation to match
   *
   * @generated from field: redpanda.core.common.ACLOperation operation = 2;
   */
  operation = ACLOperation.ACL_OPERATION_UNSPECIFIED;

  /**
   * The permission type
   *
   * @generated from field: redpanda.core.common.ACLPermissionType permission_type = 3;
   */
  permissionType = ACLPermissionType.ACL_PERMISSION_TYPE_UNSPECIFIED;

  /**
   * The host to match.  If not set, will default to match all hosts
   * with the specified `operation` and `permission_type`. Note that
   * the asterisk `*` is literal and matches hosts that are set to `*`
   *
   * @generated from field: string host = 4;
   */
  host = "";

  constructor(data?: PartialMessage<ACLAccessFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ACLAccessFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "principal", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operation", kind: "enum", T: proto3.getEnumType(ACLOperation) },
    { no: 3, name: "permission_type", kind: "enum", T: proto3.getEnumType(ACLPermissionType) },
    { no: 4, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACLAccessFilter {
    return new ACLAccessFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACLAccessFilter {
    return new ACLAccessFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACLAccessFilter {
    return new ACLAccessFilter().fromJsonString(jsonString, options);
  }

  static equals(a: ACLAccessFilter | PlainMessage<ACLAccessFilter> | undefined, b: ACLAccessFilter | PlainMessage<ACLAccessFilter> | undefined): boolean {
    return proto3.util.equals(ACLAccessFilter, a, b);
  }
}

/**
 * Status of the shadow link
 *
 * @generated from message redpanda.core.admin.v2.ShadowLinkStatus
 */
export class ShadowLinkStatus extends Message<ShadowLinkStatus> {
  /**
   * @generated from field: redpanda.core.admin.v2.ShadowLinkState state = 1;
   */
  state = ShadowLinkState.UNSPECIFIED;

  /**
   * Statuses of the running tasks
   *
   * @generated from field: repeated redpanda.core.admin.v2.ShadowLinkTaskStatus task_statuses = 2;
   */
  taskStatuses: ShadowLinkTaskStatus[] = [];

  /**
   * Status of shadow topics
   *
   * @generated from field: repeated redpanda.core.admin.v2.ShadowTopicStatus shadow_topic_statuses = 3;
   */
  shadowTopicStatuses: ShadowTopicStatus[] = [];

  constructor(data?: PartialMessage<ShadowLinkStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ShadowLinkStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(ShadowLinkState) },
    { no: 2, name: "task_statuses", kind: "message", T: ShadowLinkTaskStatus, repeated: true },
    { no: 3, name: "shadow_topic_statuses", kind: "message", T: ShadowTopicStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShadowLinkStatus {
    return new ShadowLinkStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShadowLinkStatus {
    return new ShadowLinkStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShadowLinkStatus {
    return new ShadowLinkStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ShadowLinkStatus | PlainMessage<ShadowLinkStatus> | undefined, b: ShadowLinkStatus | PlainMessage<ShadowLinkStatus> | undefined): boolean {
    return proto3.util.equals(ShadowLinkStatus, a, b);
  }
}

/**
 * Status of a task
 *
 * @generated from message redpanda.core.admin.v2.ShadowLinkTaskStatus
 */
export class ShadowLinkTaskStatus extends Message<ShadowLinkTaskStatus> {
  /**
   * Name of the task
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * State of the task
   *
   * @generated from field: redpanda.core.admin.v2.TaskState state = 2;
   */
  state = TaskState.UNSPECIFIED;

  /**
   * Reason for task being in state
   *
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * The broker the task is running on
   *
   * @generated from field: int32 broker_id = 4;
   */
  brokerId = 0;

  constructor(data?: PartialMessage<ShadowLinkTaskStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ShadowLinkTaskStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(TaskState) },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "broker_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShadowLinkTaskStatus {
    return new ShadowLinkTaskStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShadowLinkTaskStatus {
    return new ShadowLinkTaskStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShadowLinkTaskStatus {
    return new ShadowLinkTaskStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ShadowLinkTaskStatus | PlainMessage<ShadowLinkTaskStatus> | undefined, b: ShadowLinkTaskStatus | PlainMessage<ShadowLinkTaskStatus> | undefined): boolean {
    return proto3.util.equals(ShadowLinkTaskStatus, a, b);
  }
}

/**
 * Status of a ShadowTopic
 *
 * @generated from message redpanda.core.admin.v2.ShadowTopicStatus
 */
export class ShadowTopicStatus extends Message<ShadowTopicStatus> {
  /**
   * Name of the shadow topic
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Topic ID of the shadow topic
   *
   * @generated from field: string topic_id = 2;
   */
  topicId = "";

  /**
   * State of the shadow topic
   *
   * @generated from field: redpanda.core.admin.v2.ShadowTopicState state = 3;
   */
  state = ShadowTopicState.UNSPECIFIED;

  /**
   * List of partition information for the shadow topic
   *
   * @generated from field: repeated redpanda.core.admin.v2.TopicPartitionInformation partition_information = 4;
   */
  partitionInformation: TopicPartitionInformation[] = [];

  constructor(data?: PartialMessage<ShadowTopicStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.ShadowTopicStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "topic_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(ShadowTopicState) },
    { no: 4, name: "partition_information", kind: "message", T: TopicPartitionInformation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShadowTopicStatus {
    return new ShadowTopicStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShadowTopicStatus {
    return new ShadowTopicStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShadowTopicStatus {
    return new ShadowTopicStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ShadowTopicStatus | PlainMessage<ShadowTopicStatus> | undefined, b: ShadowTopicStatus | PlainMessage<ShadowTopicStatus> | undefined): boolean {
    return proto3.util.equals(ShadowTopicStatus, a, b);
  }
}

/**
 * Topic partition information
 *
 * @generated from message redpanda.core.admin.v2.TopicPartitionInformation
 */
export class TopicPartitionInformation extends Message<TopicPartitionInformation> {
  /**
   * Partition ID
   *
   * @generated from field: int64 partition_id = 1;
   */
  partitionId = protoInt64.zero;

  /**
   * Source partition's LSO
   *
   * @generated from field: int64 source_last_stable_offset = 2;
   */
  sourceLastStableOffset = protoInt64.zero;

  /**
   * Source partition's HWM
   *
   * @generated from field: int64 source_high_watermark = 3;
   */
  sourceHighWatermark = protoInt64.zero;

  /**
   * Shadowed partition's HWM
   *
   * @generated from field: int64 high_watermark = 4;
   */
  highWatermark = protoInt64.zero;

  constructor(data?: PartialMessage<TopicPartitionInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.core.admin.v2.TopicPartitionInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "partition_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "source_last_stable_offset", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "source_high_watermark", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "high_watermark", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopicPartitionInformation {
    return new TopicPartitionInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopicPartitionInformation {
    return new TopicPartitionInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopicPartitionInformation {
    return new TopicPartitionInformation().fromJsonString(jsonString, options);
  }

  static equals(a: TopicPartitionInformation | PlainMessage<TopicPartitionInformation> | undefined, b: TopicPartitionInformation | PlainMessage<TopicPartitionInformation> | undefined): boolean {
    return proto3.util.equals(TopicPartitionInformation, a, b);
  }
}

